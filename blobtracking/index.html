<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Camera Blob Detector</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            overflow: hidden; /* Prevent scrollbars from canvas resizing */
        }
        #videoCanvas {
            display: block;
            max-width: 100%;
            max-height: 80vh; /* Limit canvas height */
            height: auto;
            border: 1px solid black;
            background-color: #333; /* Placeholder color */
        }
        #controls {
            margin-top: 15px;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #controls label, #controls span {
            vertical-align: middle;
        }
        #status {
            margin-top: 10px;
            color: #555;
            font-size: 0.9em;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Blob Detector</h1>
    <video id="video" playsinline autoplay muted style="display:none;"></video>
    <canvas id="videoCanvas"></canvas>
    <div id="controls">
        <label for="threshold">Threshold (0-255): </label>
        <input type="range" id="threshold" min="0" max="255" value="128">
        <span id="thresholdValue">128</span>
    </div>
    <div id="status">Initializing...</div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        const thresholdInput = document.getElementById('threshold');
        const thresholdValueSpan = document.getElementById('thresholdValue');
        const statusDiv = document.getElementById('status');

        let currentThreshold = parseInt(thresholdInput.value, 10);
        const MIN_BLOB_PIXELS = 50; // Minimum number of pixels for a blob to be considered

        thresholdInput.addEventListener('input', (event) => {
            currentThreshold = parseInt(event.target.value, 10);
            thresholdValueSpan.textContent = currentThreshold;
        });

        function adjustCanvasSize() {
            if (!video.videoWidth || !video.videoHeight) return;

            const videoAspectRatio = video.videoWidth / video.videoHeight;
            
            let canvasWidth = window.innerWidth * 0.95; // Try to fill 95% of width
            let canvasHeight = canvasWidth / videoAspectRatio;

            const maxCanvasHeight = window.innerHeight * 0.75; // Max 75% of viewport height

            if (canvasHeight > maxCanvasHeight) {
                canvasHeight = maxCanvasHeight;
                canvasWidth = canvasHeight * videoAspectRatio;
            }
            
            // Ensure canvas width does not exceed video's natural width (unless video is very small)
            // or a reasonable maximum like 800px for performance.
            canvas.width = Math.min(canvasWidth, video.videoWidth, 800);
            canvas.height = canvas.width / videoAspectRatio;

            // Final check if height is still too much after width adjustment
            if (canvas.height > maxCanvasHeight) {
                canvas.height = maxCanvasHeight;
                canvas.width = canvas.height * videoAspectRatio;
            }

            console.log(`Canvas dimensions set to: ${canvas.width}x${canvas.height}`);
            statusDiv.textContent = 'Camera active. Processing...';
        }

        async function setupCamera() {
            try {
                statusDiv.textContent = 'Requesting camera access...';
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment', // Prefer back camera
                        width: { ideal: 640 }, // Request a reasonable resolution
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    adjustCanvasSize();
                    processFrame();
                };
            } catch (err) {
                console.error("Error accessing camera:", err);
                statusDiv.textContent = `Error: ${err.name} - ${err.message}. Ensure camera permission.`;
                alert(`Could not access the camera: ${err.message}`);
            }
        }

        function processFrame() {
            if (video.paused || video.ended || !video.videoWidth) {
                requestAnimationFrame(processFrame);
                return;
            }

            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            const thresholded = new Uint8Array(width * height);
            const visited = new Uint8Array(width * height).fill(0);

            // Grayscale and threshold
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                const pixelIndex = i / 4;
                thresholded[pixelIndex] = (gray > currentThreshold) ? 1 : 0;
            }

            const blobs = [];
            // Detect blobs using Breadth-First Search (BFS)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    if (thresholded[index] === 1 && visited[index] === 0) {
                        let minX = x, minY = y, maxX = x, maxY = y;
                        const queue = [[x, y]];
                        visited[index] = 1;
                        let pixelCount = 0;

                        while (queue.length > 0) {
                            const [cx, cy] = queue.shift();
                            pixelCount++;

                            minX = Math.min(minX, cx);
                            minY = Math.min(minY, cy);
                            maxX = Math.max(maxX, cx);
                            maxY = Math.max(maxY, cy);

                            const neighbors = [
                                [cx + 1, cy], [cx - 1, cy],
                                [cx, cy + 1], [cx, cy - 1]
                                // Add diagonal neighbors for 8-connectivity if desired
                                // [cx + 1, cy + 1], [cx - 1, cy - 1],
                                // [cx + 1, cy - 1], [cx - 1, cy + 1]
                            ];

                            for (const [nx, ny] of neighbors) {
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIndex = ny * width + nx;
                                    if (thresholded[nIndex] === 1 && visited[nIndex] === 0) {
                                        visited[nIndex] = 1;
                                        queue.push([nx, ny]);
                                    }
                                }
                            }
                        }
                        if (pixelCount >= MIN_BLOB_PIXELS) {
                             blobs.push({ x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 });
                        }
                    }
                }
            }

            // Draw bounding boxes
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 2;
            blobs.forEach(blob => {
                ctx.beginPath();
                ctx.rect(blob.x, blob.y, blob.width, blob.height);
                ctx.stroke();
            });

            requestAnimationFrame(processFrame);
        }

        window.addEventListener('resize', adjustCanvasSize);
        setupCamera();
    </script>
</body>
</html>
